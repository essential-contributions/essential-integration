use std::lib::Secp256k1Signature;
use std::lib::Secp256k1PublicKey;
use std::lib::PredicateAddress;

interface Token {
    storage {
        balances: (b256 => int),
        nonce: (b256 => int),
        token_name: b256,
        token_symbol: b256,
        decimals: int,
    }

    predicate TransferI {
        pub var key: b256;
        pub var to: b256;
        pub var amount: int;
    }

    predicate BurnI {
        pub var key: b256;
        pub var amount: int;
    }

    predicate MintI {
        pub var key: b256;
        pub var amount: int;
        pub var decimals: int;
    }
    
    predicate CancelI {
        pub var key: b256;
    }
}

// The interface of dependent constraints
interface OtherConstraints {
    predicate Constraints {
        pub var key: b256;
    }
}

enum TransferMode = All | Key | KeyTo | KeyAmount;

predicate Transfer {
    // The token address
    pub var token: PredicateAddress;

    interface T = Token(token.contract);
    predicate I = T::TransferI(token.addr);
    @common({I::key, I::to, I::amount}; T; I; token);
}

predicate TransferWith {
    // The token address
    pub var token: PredicateAddress;

    var mode: TransferMode;

    interface T = Token(token.contract);
    predicate I = T::TransferI(token.addr);
    
    var sig: Secp256k1Signature;
    var public_key: Secp256k1PublicKey;
    
    state nonce = T::storage::nonce[I::key];
    
    @check_signature_if(mode == TransferMode::All; {I::key, I::to, I::amount, nonce', token, constraints}; sig; public_key);
    @check_signature_if(mode == TransferMode::Key; {I::key, nonce', token, constraints}; sig; public_key);
    @check_signature_if(mode == TransferMode::KeyTo; {I::key, I::to, nonce', token, constraints}; sig; public_key);
    @check_signature_if(mode == TransferMode::KeyAmount; {I::key, I::amount, nonce', token, constraints}; sig; public_key);
    
    constraint __sha256(public_key) == I::key;
    constraint __mut_keys_len() == 0;
    
    var constraints: std::lib::PredicateAddress;
    interface Other = OtherConstraints(constraints.contract);
    predicate O = Other::Constraints(constraints.addr);
    constraint O::key == I::key;
}

predicate Burn {
    // The token address
    pub var token: PredicateAddress;

    interface T = Token(token.contract);
    predicate I = T::BurnI(token.addr);
    @common({I::key, I::amount}; T; I; token);
}

predicate Mint {
    // The token address
    pub var token: PredicateAddress;

    interface T = Token(token.contract);
    predicate I = T::MintI(token.addr);
    @common({I::key, I::amount, I::decimals}; T; I; token);
}

predicate Cancel {
    // The token address
    pub var token: PredicateAddress;

    interface T = Token(token.contract);
    predicate I = T::CancelI(token.addr);
    @common(I::key; T; I; token);
}

macro @common($data, $token, $predicate, $token_addr) {
    var sig: std::lib::Secp256k1Signature;
    var public_key: std::lib::Secp256k1PublicKey;
    
    state nonce = $token::storage::nonce[$predicate::key];
    
    constraint __recover_secp256k1(__sha256({$data, nonce', $token_addr}), sig) == public_key;
    constraint __sha256(public_key) == $predicate::key;
    constraint __mut_keys_len() == 0;
}

macro @check_signature_if($cond, $data, $sig, $public_key) {
    constraint ($cond && __recover_secp256k1(__sha256($data), $sig) == $public_key) || true;
}