type IntentAddress = { set: b256, intent_addr: b256 };

type Secp256k1Signature = { b256, b256, int };

type Secp256k1PublicKey = { b256, int };

macro @init_once($s, $v) {
    $s == nil && $s' == $v
}

macro @init_delta($s, $eq) {
    ($s == nil && $s' == $eq) || @delta($s) == $eq
}

// The state should increment by 1.
macro @delta($s) {
    $s' - $s
}

// The state should be initialized to 1 or incremented by 1.
macro @safe_increment($s) {
    ($s == nil && $s' == 1) || @delta($s) == 1
}

// Hash some data and then recover the public key from the signature.
// This uses the secp256k1 curve.
macro @recover($data, $sig, $key) {
    __recover_secp256k1(__sha256($data), $sig) == $key
}

macro @solution_contains($other, $intent, $intent_address) {
    interface Other = $other($intent_address.set);
    intent O = Other::$intent($intent_address.intent_addr);
}

// Constrain the mutable keys so nothing else can be modified.
macro @constrain_keys($key, &rest) {
    constraint __mut_keys_len() == @count($key; &rest);
    // TODO: Constrain that this key is contained in the proposed mutable set
}

// Base case for the above macro.
macro @constrain_keys($key) {
    constraint __mut_keys_len() == 1;
}

// Count the number of keys in the mutable set.
macro @count($i, &rest) {
    @count(&rest) + 1
}

// Base case for the above macro.
macro @count($i) {
    1
}

// Hash the address of the current intent.
macro @hash_this_addr() {
    __sha256({__this_set_address(), __this_address()})
}