storage {
    nonce: (b256 => int),
}

// The interface of dependent constraints
interface OtherConstraints {
    intent Constraints {
    }
}

intent Transfer {
    // The address that the amount is being sent key
    pub var key: b256;
    // The address that the amount is being sent to
    pub var to: b256;
    // The amount being transfered 
    pub var amount: int;
    // The instance of the transfer intent
    pub var set: b256;
    pub var intent_addr: b256;
    pub var path: int;

    var sig: ::std::lib::Secp256k1Signature;
    var public_key: ::std::lib::Secp256k1PublicKey;
    
    state nonce = storage::nonce[key];
    
    constraint ::std::lib::@recover({key, to, amount, nonce', set, intent_addr, path}; sig; public_key);
    
    @common();
}

intent TransferFromTo {
    // The address that the amount is being sent key
    pub var key: b256;
    // The address that the amount is being sent to
    pub var to: b256;
    // The amount being transfered 
    pub var amount: int;
    // The instance of the transfer intent
    pub var set: b256;
    pub var intent_addr: b256;
    pub var path: int;

    var sig: ::std::lib::Secp256k1Signature;
    var public_key: ::std::lib::Secp256k1PublicKey;
    var constraints: ::std::lib::IntentAddress;
    
    state nonce = storage::nonce[key];
    
    constraint ::std::lib::@recover({key, to, constraints.set, constraints.intent_addr, nonce', set, intent_addr, path}; sig; public_key);
    ::std::lib::@solution_contains(OtherConstraints; Constraints; constraints);

    @common();
}

intent TransferFrom {
    // The address that the amount is being sent key
    pub var key: b256;
    // The address that the amount is being sent to
    pub var to: b256;
    // The amount being transfered 
    pub var amount: int;
    // The instance of the transfer intent
    pub var set: b256;
    pub var intent_addr: b256;
    pub var path: int;

    var sig: ::std::lib::Secp256k1Signature;
    var public_key: ::std::lib::Secp256k1PublicKey;
    var constraints: ::std::lib::IntentAddress;
    
    state nonce = storage::nonce[key];
    
    constraint ::std::lib::@recover({key, constraints.set, constraints.intent_addr, nonce', set, intent_addr, path}; sig; public_key);
    ::std::lib::@solution_contains(OtherConstraints; Constraints; constraints);
    
    @common();
}

intent Cancel {
    var key: b256;
    var sig: ::std::lib::Secp256k1Signature;
    var public_key: ::std::lib::Secp256k1PublicKey;
    
    state nonce = storage::nonce[key];
    
    constraint ::std::lib::@recover({key, nonce'}; sig; public_key);

    @common();
}

macro @common() {
    constraint ::std::lib::@safe_increment(nonce);
    constraint __sha256(public_key) == key;
    ::std::lib::@constrain_keys(key);
}