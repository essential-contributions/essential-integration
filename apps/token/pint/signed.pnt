interface Token {
    storage {
        balances: (b256 => int),
        nonce: (b256 => int),
        token_name: b256,
        token_symbol: b256,
        decimals: int,
    }

    predicate TransferI {
        pub var key: b256;
        pub var to: b256;
        pub var amount: int;
    }

    predicate BurnI {
        pub var key: b256;
        pub var amount: int;
    }

    predicate MintI {
        pub var key: b256;
        pub var amount: int;
        pub var decimals: int;
    }
    
    predicate CancelI {
        pub var key: b256;
    }
}

// The interface of dependent constraints
interface OtherConstraints {
    predicate Constraints {
        pub var key: b256;
    }
}

enum TransferMode = All | Key | KeyTo | KeyAmount;

predicate Transfer {
    // The token address
    pub var contract:b256;
    pub var predicate_addr: b256;

    interface T = Token(set);
    predicate I = T::TransferI(predicate_addr);
    @common({I::key, I::to, I::amount}; T; I);
}

predicate TransferWith {
    // The token address
    pub var contract:b256;
    pub var predicate_addr: b256;

    var mode: TransferMode;

    interface T = Token(set);
    predicate I = T::TransferI(predicate_addr);
    
    var sig: std::lib::Secp256k1Signature;
    var public_key: std::lib::Secp256k1PublicKey;
    
    state nonce = T::storage::nonce[I::key];
    
    constraint (mode == TransferMode::All && __recover_secp256k1(__sha256({I::key, I::to, I::amount, nonce', set, predicate_addr, constraints.set, constraints.predicate_addr}), sig) == public_key) || true;
    constraint (mode == TransferMode::Key && __recover_secp256k1(__sha256({I::key, nonce', set, predicate_addr, constraints.set, constraints.predicate_addr}), sig) == public_key) || true;
    constraint (mode == TransferMode::KeyTo && __recover_secp256k1(__sha256({I::key, I::to, nonce', set, predicate_addr, constraints.set, constraints.predicate_addr}), sig) == public_key) || true;
    constraint (mode == TransferMode::KeyAmount && __recover_secp256k1(__sha256({I::key, I::amount, nonce', set, predicate_addr, constraints.set, constraints.predicate_addr}), sig) == public_key) || true;
    
    constraint __sha256(public_key) == I::key;
    constraint __mut_keys_len() == 0;
    
    var constraints: std::lib::PredicateAddress;
    interface Other = OtherConstraints(constraints.set);
    predicate O = Other::Constraints(constraints.predicate_addr);
    constraint O::key == I::key;
}


predicate Burn {
    // The token address
    pub var contract:b256;
    pub var predicate_addr: b256;

    interface T = Token(set);
    predicate I = T::BurnI(predicate_addr);
    @common({I::key, I::amount}; T; I);
}

predicate Mint {
    // The token address
    pub var contract:b256;
    pub var predicate_addr: b256;

    interface T = Token(set);
    predicate I = T::MintI(predicate_addr);
    @common({I::key, I::amount, I::decimals}; T; I);
}

predicate Cancel {
    // The token address
    pub var contract:b256;
    pub var predicate_addr: b256;

    interface T = Token(set);
    predicate I = T::CancelI(predicate_addr);
    @common(I::key; T; I);
}

macro @common($data, $t, $i) {
    var sig: std::lib::Secp256k1Signature;
    var public_key: std::lib::Secp256k1PublicKey;
    
    state nonce = $t::storage::nonce[$i::key];
    
    constraint __recover_secp256k1(__sha256({$data, nonce', set, predicate_addr}), sig) == public_key;
    
    constraint __sha256(public_key) == $i::key;
    constraint __mut_keys_len() == 0;
}