
type IntentAddress = { set: b256, intent_addr: b256 };

type Secp256k1Signature = { b256, b256, int };

type Secp256k1PublicKey = { b256, int };

// Check if the instance in the interface is pointing at this intent.
macro @is_this_intent($I) {
    constraint $I::set == __this_set_address();
    constraint $I::intent_addr == __this_address();
    constraint $I::path == __this_pathway();
}

// Constrain the mutable keys so nothing else can be modified.
macro @constrain_keys($key, &rest) {
    constraint __mut_keys_len() == @count($key; &rest);
    // TODO: Constrain that this key is contained in the proposed mutable set
}

// Base case for the above macro.
macro @constrain_keys($key) {
    constraint __mut_keys_len() == 1;
}

// Count the number of keys in the mutable set.
macro @count($i, &rest) {
    @count(&rest) + 1
}

// Base case for the above macro.
macro @count($i) {
    1
}

// Constrain the incoming interface to match your data.
macro @forward_data($t, $I) {
    constraint $t.key == $I::key;
    constraint $t.token == $I::token;
    constraint $t.to == $I::to;
    constraint $t.set == $I::set;
    constraint $t.intent_addr == $I::intent_addr;
    constraint $t.path == $I::path;
}

// The state should increment by 1.
macro @delta($s) {
    $s' == $s + 1
}

// The state should be initialized to 1 or incremented by 1.
macro @init($s) {
    ($s == nil && $s' == 1) || @delta($s)
}

// Hash some data and then recover the public key from the signature.
// This uses the secp256k1 curve.
macro @recover($data, $sig, $key) {
    __recover_secp256k1(__sha256($data), $sig) == $key
}

// Hash the address of the current intent.
macro @hash_this_addr() {
    __sha256({__this_set_address(), __this_address()})
}
