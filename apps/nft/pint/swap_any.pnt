
storage {
    token: int,
}

interface Nft {
    storage {
        owners: (int => b256),
    }
}

intent Init {
    interface NftInstance = Nft(0x2D6722A09661CCAAA8FFC9BCC98BF9587C6A3286C8D01AB1A61894414671527E);
    
    state current_token = storage::token;
    state token_owner = NftInstance::storage::owners[current_token'];

    constraint current_token == nil;
}

intent Swap {
    interface NftInstance = Nft(0x2D6722A09661CCAAA8FFC9BCC98BF9587C6A3286C8D01AB1A61894414671527E);
    
    pub var key: b256;
    pub var to: b256;
    pub var token: int;
    
    state current_token = storage::token;
    state current_token_owner = NftInstance::storage::owners[current_token];
    state new_token_owner = NftInstance::storage::owners[current_token'];
    
    constraint new_token_owner' == lib::@hash_this_addr();
    constraint new_token_owner' == current_token_owner;
    constraint current_token_owner' == new_token_owner;

    @check_auth(
        { key: key, token: token, to: to};
        {key: current_token_owner, token: current_token, to: new_token_owner}
    );
}

macro @check_auth($auth, $change) {
    constraint $auth.key == $change.key;
    constraint $auth.token == $change.token;
    constraint $auth.to == $change.to;
}
