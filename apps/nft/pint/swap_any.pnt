
storage {
    token: int,
}

interface Nft {
    storage {
        owners: (int => b256),
    }
}

predicate Init {
    var contract:b256;
    interface NftInstance = Nft(set);
    
    state current_token = storage::token;
    state token_owner = NftInstance::storage::owners[current_token'];

    constraint current_token == nil && token_owner' != nil;
    
    // TODO: Get hash of swap so that `token_owner'` can be constraint to the predicate address of swap.
}

predicate Swap {
    pub var key: b256;
    pub var to: b256;
    pub var token: int;
    pub var contract:b256;
    pub var predicate_addr: b256;
    pub var path: int;
    
    interface NftInstance = Nft(set);
    
    state current_token = storage::token;
    state current_token_owner = NftInstance::storage::owners[current_token];
    state new_token_owner = NftInstance::storage::owners[current_token'];
    
    constraint new_token_owner' == std::lib::@hash_this_addr();
    constraint new_token_owner' == current_token_owner;
    constraint current_token_owner' == new_token_owner;

    @check_auth(
        { key: key, token: token, to: to};
        {key: current_token_owner, token: current_token, to: new_token_owner}
    );

}

macro @check_auth($auth, $change) {
    constraint $auth.key == $change.key;
    constraint $auth.token == $change.token;
    constraint $auth.to == $change.to;
}
