storage {
    nonce: (b256 => int),
}

predicate Transfer {
    // The address that the token is being sent key
    pub var key: b256;
    // The address that the token is being sent to
    pub var to: b256;
    // The token being transfered 
    pub var token: int;
    // The instance of the transfer predicate
    pub var contract: b256;
    pub var predicate_addr: b256;
    pub var path: int;

    var sig: ::std::lib::Secp256k1Signature;
    var public_key: ::std::lib::Secp256k1PublicKey;
    
    state nonce = storage::nonce[key];
    
    constraint ::std::lib::@recover({key, to, token, nonce', contract, predicate_addr, path}; sig; public_key);
    
    @common();
}

predicate Cancel {
    var key: b256;
    var sig: ::std::lib::Secp256k1Signature;
    var public_key: ::std::lib::Secp256k1PublicKey;
    
    state nonce = storage::nonce[key];
    
    constraint ::std::lib::@recover({key, nonce'}; sig; public_key);

    @common();
}

macro @common() {
    constraint ::std::lib::@safe_increment(nonce);
    constraint __sha256(public_key) == key;
    ::std::lib::@constrain_keys(key);
}